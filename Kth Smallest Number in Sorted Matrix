// use a min_heap by a priority_queue<int, vector<int>, greater<int>>.
// first push all the element in the first row into the heap.
// in the for loop, we pop out the root and push all elements of the following row into the heap, which is to delete the min.
// after pop out k-1 times, we now have our target in the root, which is the k-th minimum number. 
// (k should be larger than 1 so that the number we want won't be popped out)
// (k-1) may be still larger than the size of matrix, which need extra operations to pop.




class Solution {
public:
    /**
     * @param matrix: a matrix of integers
     * @param k: an integer
     * @return: the kth smallest number in the matrix
     */
    int kthSmallest(vector<vector<int> > &matrix, int k) {
        // write your code here
        priority_queue<int, vector<int>, greater<int>> heap;
        
        int rowSize = matrix[0].size();
        
        for (int i = 0; i < rowSize; i++)
            heap.push(matrix[0][i]);
            
        for (int i = 1; k > 1 && i < matrix.size(); i++, k--)
        {
            heap.pop();
            
            for (int j = 0; j < rowSize; j++)
                heap.push(matrix[i][j]);
        }
        
        while (k > 1)
        {
            heap.pop();
            k--;
        }
        
        return heap.top();
    }
};
